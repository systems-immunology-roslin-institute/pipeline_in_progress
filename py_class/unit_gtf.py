#### THIS CLASS ORGANISES THE EXON INFORMATION FROM THE GTF/GFF3 FILE #####
# Please see the respective class definition scripts for more information on the input .sam and .gtf/.gff file format
## - GENENAME.gtf : extracted from the original gtf file, containing the start-end loci for each transcript and exons. Generated by py_identify_region.py
# GTF/GFF file format (downloadable from Ensembl. Needs to be the one used for sorting the .bam file)
# Although the gene annotation file can be .gtf or gff, throughout the script, it is referred to as "GTF"
# The script has only been optimalised to understand .gtf, .gff3 gene/exon annotation formats
# Both gtf and gff files are tabl delimited files with the attributes in the following columns:
#[0] seqname : name of the chromosome or scaffold; chromosome names can be given with or without the 'chr' prefix. Important note: the seqname must be one used within Ensembl, i.e. a standard chromosome name or an Ensembl identifier such as a scaffold ID, without any additional content such as species or assembly. See the example GFF output below.
#[1] source : name of the program that generated this feature, or the data source (database or project name)
#[2] feature : feature type name, e.g. Gene, Variation, Similarity
#[3] start : Start position of the feature, with sequence numbering starting at 1.
#[4] end : End position of the feature, with sequence numbering starting at 1.
#[5] score : A floating point value.
#[6] strand : defined as + (forward) or - (reverse).
#[7] frame : One of '0', '1' or '2'. '0' indicates that the first base of the feature is the first base of a codon, '1' that the second base is the first base of a codon, and so on..
#[8] attribute : A semicolon-separated list of tag-value pairs, providing additional information about each feature.

import re
import math
import py_class
import collections
from py_class.unit_gtf_transcript_model import transcript_model
from py_functions import coord_str2lst


class gtf_info(object):
    #threshold_junction_count=3
    def __init__(self, strand, transcript_name_on=True, read_junctions={}):
        self.transcript_name_on = transcript_name_on # default setting is true, which means that if "transcript_name" exists in the gtf file, use that instead for readability
        self.strand = -1 if strand == 'r' else 1 # this setting is for calculating position from the left most base
        self.annotation_by_transcriptid = {} # each item in this dictionary is of the transcript_model class. Check unit_gtf_transcript_model for details on how it works.
        self.transcriptid_order = []
        self.annotation_name = []
        self.annotation_detail = {} # track annotation detail as a dictionary and if the detail is not in the current dictionary, add new using self.annotation_detail_id 
        self.annotation_detail_id = 0 # this is used for filling self.annotation_perposition to save using large number of strings
        self.min=None
        self.max=None
        self.chromosome = None
        self.gtf_covered_positions ={}
        self.read_covered_positions ={}
        self.read_junctions = read_junctions
        self.stringtieid2name={}
        self.transcriptid_ordered=None
        self.threshold_junction_count=2 # a junction needs to account for at least 1 % of the total junctions to be considered to be true
        self.threshold_cut_window=4 # the minimum distance between exon start/ends. Junction cut at less than that will be reorganised so the junction with the highest count is used
        self.read_defined_segments = []
    # this takes in a line from a .gtf or gff file
    # and store the information into self
    # gtf types can be ensembl or merged
    def read_gtf(self, line, gtf_type='ensembl'):
        if not re.match(r'^#', line): #ignore lines that start with #
            line = line.rstrip("\n\r")
            line = re.split('\t', line)
            if len(line)>=7:
                transcript_annotation = self.transcript_annotation(val=line, gtf_type=gtf_type)
                current_transcript_id = transcript_annotation['transcript_id']
                # use the imported transcript_model object to store information about the transcript model
                if current_transcript_id not in self.annotation_by_transcriptid:
                    current_transcript_model=transcript_model()
                    self.annotation_by_transcriptid.update({current_transcript_id: current_transcript_model})
                self.annotation_by_transcriptid[current_transcript_id].add_annotation(transcript_annotation)
                # add in chromosome annotation if it is not already present
                if not self.chromosome:
                    self.chromosome=str(line[0]).replace("chr","")
            
    def transcript_annotation(self, val, gtf_type):
        current_coord = sorted([int(val[3]), int(val[4])])
        # check for min/max defined in self.min and self.max and replace appropriately
        self.min = current_coord[0] if (self.min is None or self.min > current_coord[0]) else self.min
        self.max = current_coord[1] if (self.max is None or self.max < current_coord[1]) else self.max
        match_str_transcript_id = {'gtf_name':r'^.*?transcript_name \"(.*?)\";.*?$', 
                                   'gtf_id': r'^.*?transcript_id \"(.*?)\";.*?$',
                                   'stringtie_gene_id': r'^.*?gene_id \"(.*?)\";.*?$',
                                   'stringtie_gene_name': r'^.*?gene_name \"(.*?)\";.*?$',
                                   'gff3':r'^.*?Parent=transcript:(.*?);.*?$', }
        transcript_id, gene_name = [None, None]
        if gtf_type== 'merged_gtf':
            if re.match(match_str_transcript_id['stringtie_gene_id'], val[8]):
                transcript_id=re.search(match_str_transcript_id['stringtie_gene_id'], val[8]).group(1)
            if re.match(match_str_transcript_id['stringtie_gene_name'], val[8]):
                gene_name=re.search(match_str_transcript_id['stringtie_gene_name'], val[8]).group(1)
            transcript_id="merged_gtf_%s" %transcript_id
            # If the line contains both transcript_id and gene name, record this and this will be used to rename the transcript_id later
            if transcript_id and gene_name:
                self.stringtieid2name[transcript_id]=gene_name
        elif re.match(match_str_transcript_id['gtf_name'], val[8]):
            transcript_id= re.search(match_str_transcript_id['gtf_name'], val[8]).group(1)
        elif re.match(match_str_transcript_id['gtf_id'], val[8]):
            transcript_id= re.search(match_str_transcript_id['gtf_id'], val[8]).group(1)
        elif re.match(match_str_transcript_id['gff3'], val[8]):
            transcript_id= re.search(match_str_transcript_id['gff3'], val[8]).group(1)
        elif re.match(match_str_transcript_id['stringtie_gene_name'], val[8]):
            transcript_id= re.search(match_str_transcript_id['stringtie_gene_name'], val[8]).group(1)
        elif re.match(match_str_transcript_id['stringtie_gene_id'], val[8]):
            transcript_id= re.search(match_str_transcript_id['stringtie_gene_id'], val[8]).group(1)
        else: # this is not ideal as it might end up combining information from both strands if they are both in the gtf file
            transcript_id="check_match_str"         
        annotation_type = val[2].lower()
        return({'transcript_id': transcript_id, 'coord' : current_coord,'annotation_type':annotation_type, 'strand':val[6], 'gtf_type':gtf_type})
    # Combine the annotations for merged_models
    def rename_merged_gtf_ids(self):
        for transcript_id in self.stringtieid2name:
            original_base=re.sub("merged_gtf_","",transcript_id)
            new_transcript_id="merged_gtf_%s_%s" %(self.stringtieid2name[transcript_id], original_base)
            self.annotation_by_transcriptid[new_transcript_id]=self.annotation_by_transcriptid[transcript_id]
            del self.annotation_by_transcriptid[transcript_id]
    # this defines the annotation for each position with an exon annotation for each transcript model
    # and generates an overall annotation
    def position_annotation_exon(self):
        self.transcriptid_ordered = set(sorted(list(self.annotation_by_transcriptid.keys())))
        for transcriptid in self.annotation_by_transcriptid:
            self.annotation_by_transcriptid[transcriptid].make_exon_dict()
            self.annotation_by_transcriptid[transcriptid].make_other_dict()
            self.annotation_by_transcriptid[transcriptid].merge_exon_other()
            covered_coords = set(list(self.annotation_by_transcriptid[transcriptid].merged_dict.keys()))
            for coord in covered_coords:
                self.gtf_covered_positions[coord] = 0 if coord not in self.gtf_covered_positions else 0
            #print(self.annotation_by_transcriptid[transcriptid].other_dict)

    # This function allows a coordinate_set to be taken in, and return a hash with the counts for mapped coordinates for each transcript model
    def compare_coord_gtf(self, coord_in):
        # go through each transcript_id
        # return a dictionary with the summary for each transcript_id
        out_dict={}
        coord_lst=coord_str2lst(coord_in)
        coord_lst_flat=set([val for coordset in coord_lst for val in range(coordset[0], coordset[1]+1)])
        for transcript_id, transcript_id_unit in self.annotation_by_transcriptid.items():   
            out_dict.update({transcript_id:{}})
            exon_common_coord=list(set(transcript_id_unit.exon_dict.keys()).intersection(coord_lst_flat))           
            exon_common_coord_val=[transcript_id_unit.exon_dict[coord] for coord in exon_common_coord]
            out_dict[transcript_id]=dict(collections.Counter(exon_common_coord_val))
        return(out_dict)
    # This takes in a list of segments from the unit_reads.py object
    # and generate an additional track that is "merged_gene_annotation"
    def add_read_defined_segments(self, segments):
        current_transcript_model=transcript_model()
        self.read_defined_segments = current_transcript_model.defined_by_segment_list(segment_list=segments, strand=self.strand)
        self.annotation_by_transcriptid.update({'_merged_annotation': current_transcript_model})